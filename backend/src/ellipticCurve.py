import math
import os
import random
import imgToDat
import numpy as np
from PIL import Image

# read_inverse will read the inverse of 1 to p-1 from the file
def read_inverse(filename):
    # open the file with the name of filename
    file = open(filename, "r")
    # read the content of the file
    inverse = file.read()
    # split the content into a list of strings with comma as the delimiter
    inverse = inverse[1:len(inverse) - 1].split(', ')
    file.close()
    # return the list of strings
    return inverse

# calc_inverse will take a prime number and a filename as input and caluculate the inverse.
def calc_inverse(prime, filename):
    # create a list of length prime
    inv = [0] * prime
    # the inverse of 1 is 1
    inv[1] = 1
    # calculate the inverse of 2 to prime-1
    for i in range(2, prime):
        inv[i] = (prime - prime // i) * inv[prime % i] % prime
    # open the file with the name of filename
    file = open(filename, 'w')
    file.write(str(inv))
    file.close()


class Elliptic:
    """
        Initialize the elliptic curve.

        :param prime: Prime number for the elliptic curve.
        :param aa: Coefficient 'a' in the elliptic curve equation.
        :param bb: Coefficient 'b' in the elliptic curve equation.
        :param file_name: Name of the file containing precomputed inverses.
        :param xg: Ground point x-coordinate.
        :param yg: Ground point y-coordinate.
    """
    def __init__(self, prime, aa, bb, file_name, xg=None, yg=None):
        self.p = prime
        self.a = aa
        self.b = bb
        if xg is None and yg is None:
            self.xGround, self.yGround = Elliptic.find_first_feasible(self)
        else:
            self.xGround, self.yGround = xg, yg
        self.inverse = read_inverse(file_name)
        self.n = 1
        self.priv_key = 2
        self.public_key = None

    # Function to get the modular inverse of a value
    def get_inverse(self, value):
        if value >= len(self.inverse):
            return Elliptic.get_inverse_complex(self, value)
        return int(self.inverse[value])

    # More complex method of finding modular inverse if not precomputed
    def get_inverse_complex(self, value):
        for i in range(1, self.p):
            if (i * value) % self.p == 1:
                return i
        return -1

    # Function to perform a step in the elliptic curve cryptography
    def step(self, x1, y1, x2, y2):
        neg = 0
        if x1 == x2 and y1 == y2:
            mem = 3 * (x1 ** 2) + self.a
            denom = 2 * y1
        else:
            mem = y2 - y1
            denom = x2 - x1
            if mem * denom < 0:
                neg = 1
                mem = abs(mem)
                denom = abs(denom)

        factor = math.gcd(mem, denom)
        mem = mem // factor
        denom = denom // factor
        denom_inverse = Elliptic.get_inverse(self, denom)
        if neg == 1:
            k = ((-1) * mem * denom_inverse) % self.p
        else:
            k = (mem * denom_inverse) % self.p

        x3 = (k ** 2 - x1 - x2) % self.p
        y3 = (k * (x1 - x3) - y1) % self.p
        return x3, y3

    # Function to find the order of the group generated by the ground point
    def get_n(self):
        neg_x1 = self.xGround
        neg_y1 = (-1 * self.yGround) % self.p
        temp_x = self.xGround
        temp_y = self.yGround
        while self.n:
            self.n += 1
            temp_x, temp_y = Elliptic.step(self, temp_x, temp_y, self.xGround, self.yGround)
            if temp_x == neg_x1 and temp_y == neg_y1:
                self.n += 1
                break

    def get_dot(self, x0):
        y_expect = (x0 ** 3 + self.a * x0 + self.b) % self.p
        for i in range(self.p):
            if i ** 2 % self.p == y_expect:
                y0 = i
                x1 = x0
                y1 = (-1 * i) % self.p
                return x0, y0, x1, y1

    # Function to compute a multiple of the ground point
    def get_ng(self, xg, yg, priv_key):
        end_x = xg
        end_y = yg
        for _ in range(priv_key):
            end_x, end_y = Elliptic.step(self, end_x, end_y, xg, yg)
        return end_x, end_y

    # Function to generate the public key
    def get_key(self):
        Elliptic.get_n(self)
        # input('key length(<%d)ï¼š' % self.n)
        self.priv_key = 61
        xk, yk = Elliptic.get_ng(self, self.xGround, self.yGround, self.priv_key)
        self.public_key = (xk, yk)

    # Function to encrypt data using the elliptic curve
    def encrypt2(self, plain):
        output = []
        for char in plain:
            intchar = int(char)
            r = random.randint(2, self.n // 2)
            kGx, kGy = Elliptic.get_ng(self, self.xGround, self.yGround, r)  # kG
            kQx, kQy = Elliptic.get_ng(self, self.public_key[0], self.public_key[1], r)  # kQ
            cipher = intchar * kQx
            output.append([kGx, kGy, cipher])
        return output
    
    # Function to decrypt data encrypted using the elliptic curve
    def decrypt2(self, code):
        decipher = []
        for charArr in code:
            kQx, kQy = Elliptic.get_ng(self, charArr[0], charArr[1], self.priv_key)
            if kQx < 1e-8:
                decipher.append(np.uint8(charArr[2] * 1000))
            else:
                decipher.append(np.uint8(charArr[2] // kQx))
        return decipher
    
    # Function to find a feasible point on the curve
    def find_first_feasible(self):
        for i in range(self.p):
            v = Elliptic.get_dot(self, i)
            if v is not None:
                x0, y0, x1, y1 = v
                return x0, y0

# Function to encrypt an image and save the encrypted data
def encrypt_to_disk(name):
    p = 487
    # p = 997
    a = 0
    b = 3

    document = "inverse_p" + str(p) + ".txt"
    if not os.path.exists(document):
        calc_inverse(p, document)
    ECC = Elliptic(p, a, b, document)

    ECC.get_key()
    print("Key generated successfully!")
    # name = input("enter the file path and name: ")
    # img = Image.open(name)
    # plain = np.array(list(img.getdata())).reshape(-1)
    plain = imgToDat.compressedImg(name)
    encrypted_data = ECC.encrypt2(plain)#, plain
    print("Data encrypted successfully!")
    imgToDat.encrypt_to_disk_as_image(encrypted_data)
    return encrypted_data

# Function to decrypt data and reconstruct the image
def decrypt_to_pic(c):
    p = 487
    # p = 997
    a = 0
    b = 3

    document = "inverse_p" + str(p) + ".txt"
    if not os.path.exists(document):
        calc_inverse(p, document)
    ECC = Elliptic(p, a, b, document)

    ECC.get_key()
    de = ECC.decrypt2(c)
    return de


###########################################################
# # testing code
if __name__ == '__main__':
    encrypt = encrypt_to_disk("./img/original_space.png")
    # imgToDat.compressedImg("./img/original_space.png")
    de = decrypt_to_pic(encrypt)
    # print(encrypt)
    # ff = open("tttt.txt", 'w')
    # ff.write(str(de))
    # ff.close()
    imgToDat.restoreImg(de, "trial.png")

    # if len(encrypt) == len(de):
    #     print("same length")
    #     # for j in range(len(plain)):
    #     #     if plain[j] != int(de[j]):
    #     #         print(plain[j], end=' ')
    #     #     if max(encrypt[j]) > 131000:
    #     #         print(encrypt[j])
    #     # print()
    # else:
    #     print("no equal length")
